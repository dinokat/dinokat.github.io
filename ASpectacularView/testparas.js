// Generated by CoffeeScript 2.1.1
(function() {
  var Koffie, P, S, Uq, _drawTestPoint, draw, j, l, len, len1, line1, line1Line2Point, line2, p, pA, pB, pp, s1, s2, s4, t, testen;

  Koffie = document.getElementById("koffie");

  Koffie.innerHTML = "we testen die shit! <br>";

  testen = [];

  p = function(t) {
    return testen.push(t);
  };

  pp = () => {
    return testen.push(this);
  };

  Uq = (function() {
    class Uq {
      constructor(fn, prps) {
        this.uq = `ding${Uq.qs}`;
        Uq.qs++;
        this.fn = fn;
        this.prps = prps;
      }

    };

    Uq.qs = 0;

    return Uq;

  }).call(this);

  P = class P {
    constructor(x = 0, y = 0) {
      this.x = x;
      this.y = y;
      this.slaves = [];
    }

    assign(k, para) {
      this.slaves.push(k);
      return k.prps[para] = this;
    }

    reassign(k, para, p2) {
      p("reassigning");
      if (this.slaves.indexOf(k) !== -1) {
        this.slaves.splice(this.slaves.indexOf(k), 1);
      }
      p2.slaves.push(k);
      k.prps[para] = p2;
      return p2.recalc();
    }

    recalc() {
      var j, k, len, ref, results;
      ref = this.slaves;
      results = [];
      for (j = 0, len = ref.length; j < len; j++) {
        k = ref[j];
        results.push(k.fn());
      }
      return results;
    }

    str() {
      return `(${this.x}, ${this.y})`;
    }

  };

  pA = new P(3, 5);

  pB = new P(7, 4);

  S = (function() {
    class S {
      constructor(pp1, pp2) {
        this.ps = [pp1, pp2];
        this.key = new Uq(this.recalc, this.ps);
        pp1.assign(this.key, 0);
        pp2.assign(this.key, 1);
      }

      recalc() {
        return p("recalcfffffing");
      }

      reassign(i, pn) {
        var j, len, t;
        //@"#{para}".reassign(@, para, pn)
        p("in reassign");
        for (j = 0, len = testen.length; j < len; j++) {
          t = testen[j];
          Koffie.insertAdjacentHTML('beforeend', `${t}<br>`);
        }
        return this.ps[S.PAR[i]].reassign(this.key, S.PAR[i], pn);
      }

      str() {
        return `----------------------<br> p1 = ${this.ps[0].str()} <br> p2 = ${this.ps[1].str()}) <br> key = ${this.key.uq} <br> -------------------------`;
      }

    };

    S.PAR = {
      'p1': 0,
      'p2': 1
    };

    return S;

  }).call(this);

  s1 = new S(pA, pB);

  s2 = new S(pB, pA);

  p(s1.str());

  s1.reassign('p1', pB);

  p(s1.str());

  p(s2.str());

  s2 = new S(pA, new P(0, 0));

  s4 = new S(pA, new P(0, 0));

  //s1.toString()
  draw = SVG('drawing').size(400, 400);

  line1 = draw.line(19, 127, 252, 386).attr({
    stroke: 'blueviolet',
    'stroke-width': 2
  });

  line2 = draw.line(140, 45, 18, 250).attr({
    stroke: 'darkorange',
    'stroke-width': 2
  });

  p("fuckfuckfffHOERA HOERA HOERA ff");

  for (j = 0, len = testen.length; j < len; j++) {
    t = testen[j];
    Koffie.insertAdjacentHTML('beforeend', `${t}<br>`);
  }

  line1Line2Point = line1.intersectsLine(line2);

  p(line1Line2Point);

  _drawTestPoint = function(point, color, radius) {
    color = color;
    radius = radius;
    return draw.circle(radius).move(point.x - radius / 2, point.y - radius / 2).attr({
      'fill': color
    });
  };

  line1Line2Point && _drawTestPoint(line1Line2Point, 'red', 5);

  p("fuckfuckfffHOERA HOERA HOERA ff");

  for (l = 0, len1 = testen.length; l < len1; l++) {
    t = testen[l];
    Koffie.insertAdjacentHTML('beforeend', `${t}<br>`);
  }

}).call(this);
